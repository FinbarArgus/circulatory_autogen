{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Circulatory Autogen","text":"<p>Circulatory Autogen aims to automate the process of combining CellML modules into a system model, then doing parameter identification to calibrate to clinical data. </p> <p>Common use cases include generating coupled biochemical cell models, generating neuron to cardiomyocyte models, generating patient specific 0D blood flow networks and more.</p>"},{"location":"#why-circulatory-autogen","title":"Why Circulatory Autogen","text":"<p>Circulatory Autogen provides the following benefits.</p> <ul> <li> <p>Allows module reusability in system models:</p> <p>This software allows reusability and easy coupling of CellML modules. A wide range of openly available modules can be accessed and easily coupled to whatever modules you want to develop. Therefore, instead of having one huge model that will rarely be reused, you can easily integrate modules to create a system model and the modules can be used by others. </p> </li> <li> <p>Provides the ability to calibrate model parameters to clinical or experimental data:</p> <p>This software supports parameter identification algorithms which you can use to calibrate the model parameters to clinical or experimental data.</p> </li> <li> <p>Code generation</p> <p>By generating models in CellML, the user can then re-generate their model in whatever language they want (C++, Fortran, Matlab) with libcellml. This allows for easy coupling with other types of models (PDE), C generation for embedded systems, and much more. </p> </li> <li> <p>Open Source</p> <p>Circulatory Autogen is completely open source. Unlike Software like Simulink, you will never need to pay to use Circulatory Autogen and you can continue using it outside of academia. This further promotes reproducible science by encouraging anyone to use and check the modules or models that are created.</p> </li> </ul>"},{"location":"#what-circulatory-autogen-can-do","title":"What Circulatory Autogen can do","text":"<p>Circulatory Autogen provides the following two main functionalities.</p> <ol> <li> <p>Model Autogeneration</p> <p>This generates a system model by combining CellML modules in a user-defined network/arrangement. For more information, refer section Model Generation and Simulation.</p> </li> <li> <p>Parameter Identification</p> <p>This allows calibrating model parameters to data. See section Parameter Identification for more information.</p> </li> </ol>"},{"location":"design-model/","title":"Designing a model","text":"<p>This section describes how to design a model to be run in Circulatory Autogen. There are two sub sections included in this guide as follows.</p> <ol> <li> <p>Creating a new model</p> </li> <li> <p>Converting an existing CellML model to run in Circulatory Autogen</p> </li> </ol>"},{"location":"design-model/#creating-a-new-model","title":"Creating a new model","text":"<p>This software is designed so the user can easily make their own modules and couple them with existing modules. The steps are as follows.</p> <ol> <li> <p>Either choose an existing <code>[module_category]_modules.cellml</code> file to write your module, or if it is a new category of module, create a <code>[module_category]_modules.cellml</code> file in <code>[project_dir]/module_config_user/</code>.</p> </li> <li> <p>Put your cellml model into the <code>[module_category]_modules.cellml</code> file.</p> </li> <li> <p>Create a corresponding module configuration entry into <code>[module_category]_config.json</code> within <code>[project_dir]/module_config_user/</code>. These module declarations detail the variables that can be accessed, the constants that must be defined and the available ports of the module.</p> </li> <li> <p>When possible, use units defined in <code>[project_dir]/src/generators/resources/units.cellml</code>. If  you need to define new units, define them in <code>[project_dir]/module_config_user/user_units.cellml</code></p> </li> <li> <p>Include your new module into a <code>[CA_user_dir]/[file_prefix]_vessel_array.csv</code> file.</p> <p>Note</p> <p>Modules that are connected as each others inputs and outputs will be coupled together with any ports with corresponding name. </p> <p>For an example, if VesselOne has an exit_port 'vessel_port' and VesselTwo has an entrance_port 'vessel_port', they will be coupled with the variables declared in their corresponding 'vessel_port'. You must be careful when making a new module, that the modules it couples to only has matching port types for the ones that are necessary for coupling.</p> <p>Additionally, if a module has a general_port [port_name], it will couple to any entrance, exit, or general port in a connected vessel with the port name [port_name]. </p> <p>Standard usage: entrance and exit ports are used for spatial connections (e.g. exit to entrance of a parent and daughter vessel), whereas general ports are used for non-spatial connections (e.g a port for a material property of a whole vessel)</p> </li> <li> <p>Define model constants in a <code>[CA_user_dir]/[file_prefix]_parameters.csv</code> file. OR run the autogeneration, which will call an error and create a <code>[CA_user_dir]/[file_prefix]_parameters_unfinished.csv</code>. See model generation and simulation</p> </li> </ol> <p>The following sections include more details on creating the above required files.</p>"},{"location":"design-model/#creating-vessel_array-and-parameter-files","title":"Creating vessel_array and parameter files","text":"<p>This section discusses creating a vessel_array and parameters files to build a new desired model.</p> <p>One standard vessel array file contains five important columns as elaborated in the table below. </p> <ul> <li>vessel_name is the name of a common organ or part of the cardiovascular system.</li> <li>BC_type is the type of the boundary condition for the vessel's input and output or more generally, the subtype of the module.</li> <li>vessel_type can be defined as the desired module which exists in the <code>[project_dir]/src/generators/resources/module_config.json</code> or one of the <code>[project_dir]/module_config_user/[model_category]_config.json</code> file. </li> <li>inp_vessel is the input of each part.</li> <li>out_vessel is the output of each part.</li> </ul> <p>Some examples of possible inputs</p> Column name Possible inputs vessel_name User defined, but it is better to use common names like 'heart', 'pvn', 'par', etc. BC_type 'vv', 'vp', 'pv', 'pp', 'pp_wCont', 'pp_wLocal', 'nn' (linked to BC_type in the module_config.json file) vessel_type 'heart', 'arterial', 'arterial_simple', 'venous', 'terminal', 'split_junction', 'merge_junction', '2in2out_junction', 'gas_transport_simple', 'pulomonary_GE', 'baroreceptor', 'chemoreceptor' (linked to vessel_type in the module_config.json file) inp_vessels name of the input vessels, which is one (or more) of the vessel_name entries in the other rows out_vessel name of the output vessels, which is one (or more) of the vessel_name entries in other rows <p>Below figure is an example of a vessel_array file.</p> <p></p> <p>Every row of the vessel array file represents a specific part or module in the defined system. Therefore, each module needs several parameters for modeling and generating a CellML file.</p> <p>These parameters should be inserted in the parameters file: <code>[resources_dir]/[file_prefix]_parameters.csv</code>.</p> <p>This file has the structure as shown below.</p> Column Name Description variable_name Parameter name units Unit in the defined units in CellML's unit file value Value of parameter data_reference Reference of the parameter value. Typically in [last_name][date][first_word_of_paper] format for papers. <p>The following is an example of a parameter file.</p> <p></p> <p>Note</p> <p>If you forget to add or insert any needed parameter in the file when you run the code, it shows you this message at the end:</p> <p></p> <p>At this time, you should open the <code>[resources_dir]/[file_prefix]_parameters_unfinished.csv</code>, which will include the parameters which were not inserted in the file with EMPTY_MUST_BE_FILLED value and data_reference entries. You should add the parameter value and reference, then copy the line to the original [file_prefix].csv file. Or you can add the value in the _unfinished.csv file then remove the last part of the file's name (\u201c_unfinished\u201d) (overwriting the original) and rerun the code with the correctly set parameters.</p>"},{"location":"design-model/#modules-and-definition-of-a-new-module","title":"Modules and definition of a new module","text":"<p>In the <code>[CA_dir]/src/generators/resources</code> directory, there are several CellML files which contain the modules that can be coupled together in your model. The <code>module_config.json file</code> defines the connection ports and variables of each cellml module. Additionally the cellml and .json files in module_config.user contains more available modules that have not yet been accepted into the source code.</p> <p></p> <p>If you want to create a new module, you can create or add to a <code>module_config_user/[module_category]_modules.cellml</code> and link to the file where the cellml file is contained, e.g. <code>tutorial_modules.cellml</code> or another cellml file in <code>[CA_dir]/module_config_user/</code> or <code>[CA_dir]/src/generators/resources/</code>.</p> <p>As shown in the below figure, there are three different parts for each module. The primary specification includes vessel_type, boundary condition type, and module_file, then the ports and their types, and finally, variables and constants.</p> <p></p> <p>Following is one of the modules in the <code>BG_modules</code> file. The main body of a specific module contains variables declaration, constitutive parameters, and state variables. Then, the constitutive relations and eventually, ODE equations.</p> <p></p>"},{"location":"design-model/#example-of-creating-a-new-module","title":"Example of creating a new module","text":"<p>This section shows a simple example to create a new module</p> <p>We want to define a new vessel type with the name of \"arterial\" with boundary condition type \"vp\". Additionally, we want to use the \"vp_type\" module, whose cellml code is shown in the above figure. Also, the module is located in the <code>BG_modules.cellml</code> file.</p> <p>Vessel_type, BC_type, module_format, module_file location, module_type and other related information are added to the <code>module_config.json</code> file, as shown below. We can now use this vessel_type in the vessel_array file in <code>[resources_dir]</code> to add the module with specified inputs, outputs and parameters. In the ports, you should add the \"vessel_port\" type for connecting to the other parts. Additionally, each module can be used in many vessel_types.</p> <p></p> <p>The entries in the <code>module_config.json</code> file are detailed as follows:</p> <ul> <li>vessel_type: This will be the \"vessel_type\" entry in the vessel_array file</li> <li>BC_type: This will be the \"BC_type\" entry in the vessel_array file</li> <li>module_format: Currently only cellml is supported but in the future, cpp modules and others will be allowed.</li> <li>module_file: The file within <code>[CA_dir]/src/generators/resources/</code> or <code>[CA_dir]/module_config_user/</code> that contains the cellml module that this config entry links to.</li> <li>module_type: The name of the module/computational_environment within the module cellml file.</li> <li>entrance_ports: Specification of the port types that this module can take if it is connected as an \"out_vessel\" to another module. If a port_type matches to the port_type of a exit_port in a module coupled as an input, then the port_types variables, e.g. [v_in, u] get mapped to the variables in the coupled modules exit port e.g. [v, u_out].</li> <li>exit_ports: Specification of the port types that this module can take if it is connected as an \"inp_vessel\" to another module.</li> <li>general_ports: Specification of the port types that this module can take if it is connected as any type of connection to another module. Port entries are:<ul> <li>port_types: The name of the type of port. If two vessels are connected vessel_a to vessel_b, and vessel_a has an exit_port with the same port_type as an entrance_port of vessel_b, then a connection will be made. </li> <li>variables: These are the variables within the module that will be connected to the variables in the corresponding port of the connected vessel/module.</li> </ul> <p>Note</p> <p>If you want a port variable to be able to couple to multiple other modules, you must set <code>\"multi_port\": \"True\"</code> as an entry within the entrance, exit, or general port.</p> </li> <li> <p>variables_and_units: This specifies all of the constants and the accesible variables of the cellml module. The entries are:</p> <ul> <li>[0] variable name: corresponding to the name in the cellml file</li> <li>[1] variable unit: corresponsing to the unit specification in <code>units.cellml</code></li> <li>[2] access or no_access: whether the variable can be accessed within the cellml simulation. This should always be \"access\" for accessibility, unless you want to decrease memory usage.</li> <li>[3] parameter type: can be constant, global_constant, variable, or boundary_condition.</li> <li>If parameter_type is boundary_condition it will be set to a variable accesses from another module if the corresponding port is connected. However, if the      corresponding port is not connected, the boundary_condition will be set to a constant, and required to be set in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file </li> </ul> <p>Note</p> <p>All constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file with the following naming convention: [variable_name]_[vessel_name].</p> <p>All global_constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file as just [variable_name].</p> </li> </ul>"},{"location":"design-model/#converting-an-existing-cellml-model-to-run-in-circulatory-autogen","title":"Converting an existing CellML model to run in Circulatory Autogen","text":"<p>Circulatory Autogen provides a script to convert an existing cellml model (with parameters hardcoded in the modules) to a format that can be used with Circulatory_Autogen, which is a format that defines parameters in a separate file so that they can be used in model calibration and specifies modules in a config file with ports for easy coupling of modules.).  You can find the script \"generate_modules_files.py\" at <code>[CA_dir]/src/scripts</code>.</p> <p>Update the script to change the <code>input_model</code> variable to the path of your CellML model and <code>output_dir</code> variable to the directory where you need to create the resources files and the new <code>[file_prefix]_user_inputs.yaml</code> file.</p> <p>This script generates the <code>[file_prefix]_modules.cellml</code> and <code>module_config.json</code> files in the <code>module_config_user</code> directory. <code>[file_prefix]_parameters.csv</code> and <code>[file_prefix]_vessel_array.csv</code> files are created in <code>[output_dir]/resources</code> and the <code>[file_prefix]_user_inputs.yaml</code> is created in <code>[output_dir]</code>.</p> <p>You only need to update the <code>user_inputs.yaml</code> file at the <code>user_run_files</code> directory to update <code>user_inputs_path_override:</code> to <code>[output_dir]/[file_prefix]_user_inputs.yaml</code> to run model autogeneration.</p> <p>Note</p> <p>You can update the file_prefix, vessel_name and the data_reference variables in the <code>generate_modules_files.py</code> at the <code>src/scripts</code> directory before running the script, so it will generate files with the defined variables.</p> <p>Warning</p> <p>You need to specify the variable name of time as the time_variable.</p> <p>Variable component_name should be the name of the component for which you want to generate files.</p>"},{"location":"example-3compartment-model/","title":"Example: 3Compartment Model","text":"<p>A schematic view of this model is shown above with details of boundary conditions, parts' names, vein connection, and direction of blood flow through. The heart is modeled as a simple valve module in this example. According to this schematic, the vessel and parameters files are designed as shown in below figures.</p> <p></p> <p></p> <p>In the <code>vessel_array</code> file, there are five columns: name, BC_type, vessel_type, inp_vessels, and out_vessels. </p> <p>name is the user-chosen module's name, for example \"heart\" or \"aortic_root\". </p> <p>BC_type is the boundary condition type for circulatory system vessels. The BC of vessel modules should be one of the \"vv\", \"vp\", \"pv\", and \"pp\" types. The first letter defines input pressure (p) or flow (v) boundary condition, the second letter defines output pressure (p) or flow (v) boundary condition. For example the pulmonary vein (pvn) in the above example has a vp BC type, meaning it has input flow and output pressure boundary conditions.</p> <p>Info</p> <p>A vessel with \"output flow\" BC must be connected to a vessel with \"input pressure\" BC and vice versa. E.g. a \"vp\" can only have either a \"vv\" or \"vp\" vessel as ouputs. This is checked in the software, and will throw an error if there are incorrect BC connections.</p> <p>The vessel_type and BC_type must match a module with the same vessel_type and BC_type in the modules_config.json defined at <code>[CA_dir]/src/generators/resources/</code>. </p> <p>This file is the config file which defines the variables of a module and the connection ports that allows linking between modules, each module links to a cellml module. For more information, refer Creating a new model section.</p> <p>inp_vessels and out_vessels are the inputs and outputs of each module, respectively. Some modules have multiple inputs and outputs, like split_type vessels that split from one to two vessels.</p> <p>Note</p> <p>The order of input and output vessels is important for the heart module. The order must be:</p> <p>inp_vessels:</p> <ol> <li>inferior vena cava</li> <li>superior vena cava</li> <li>pulmonary vein</li> </ol> <p>out_vessels: </p> <ol> <li>aorta</li> <li>pulmonary artery</li> </ol> <p>A simple two-vessel pulmonary system will be used if the pulmonary vessels are not included.</p> <p>Tip</p> <p>Currently, the terminal vessels should only have a BC_type starting with \"pp\".</p> <p>Results:</p> <p>In the below figure, three different variables are plotted versus time. The step size was adjusted to 0.01 seconds. These variables are the \"Aortic_root flow rate\", \"pvn flow rate\", and the \"volume of the heart\", respectively. </p> <p>This is the model before doing model calibration. See section Parameter Identification for info on the parameter identification.</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#initialising-and-startup","title":"Initialising and Startup","text":"<p>1. Install OpenCOR</p> <p>Download and install OpenCOR version 0.8.1 from this link. I recommend installing with zip/tarball in a directory where you have access and edit rights, such as ~/Desktop.</p> <p>Note</p> <p>If you are not familiar with OpenCOR, you should go through the OpenCOR Tutorial before starting this</p> <p>Download the OpenCOR tutorial, which is a comprehensive tutorial including many examples: OpenCOR Tutorial.</p> <p>2. Clone the project</p> <p>Clone the Circulatory Autogen project from the GitHub repository.</p> <p>Note</p> <p>If you have not worked with git and GitHub, firstly download and install git, and then open the terminal and navigate (with terminal in Linux/Mac or gitbash in Windows) to a directory where you want the repository to be. Then write these commands to clone the project on your pc:</p> <ul> <li><code>git clone https://github.com/FinbarArgus/circulatory_autogen</code></li> </ul> <p>If you want to develop the code, then create a fork of the above repo in GitHub, then do the following lines instead of the above:</p> <ul> <li> <p><code>git clone https://github.com/&lt;YourUsername&gt;/circulatory_autogen</code></p> </li> <li> <p><code>git remote add upstream https://github.com/FinbarArgus/circulatory_autogen</code></p> </li> </ul>"},{"location":"getting-started/#directory-definition","title":"Directory Definition","text":"<p>In this tutorial, we define the project_dir as the directory where the Github Circulatory Autogen project has been cloned. For example, on our computer, this directory is as below:</p> <p><code>[project_dir]: ~/Documents/git_projects/Circulatory_autogen</code></p> <p>Also, the OpenCOR directory is needed for installing the necessary python libraries, which we defined as the OpenCOR_dir, e.g.:</p> <p><code>[OpenCOR_dir]: ~/Desktop/OpenCOR-0-8-1-Linux/</code></p> <p>Info</p> <p>If running on the ABI HPC, you can use the installed OpenCOR version at the path: /hpc/farg967/OpenCOR-0-8-1-Linux/ and Ignore the below installation steps, as the libraries are already installed. See running on hpc</p>"},{"location":"getting-started/#python-and-libraries-installation","title":"Python and Libraries Installation","text":"<p>To run openCOR, you need to use the Python version that is shipped with openCOR. </p> <p>To install required python packages, navigate to <code>[OpenCOR_dir]</code> directory and run the below command.</p> <p>Note</p> LinuxMacWindows <pre><code>./pip install &lt;packagename&gt;\n</code></pre> <pre><code>./pythonshell -m pip install &lt;packagename&gt;\n</code></pre> <pre><code>./pythonshell.bat -m pip install &lt;packagename&gt;\n</code></pre> <p>Note</p> <p>Required packages for autogeneration: pandas pyyaml rdflib</p> <p>Recommended (but not required) packages for autogeneration (allows for better error checking): libcellml</p> <p>Required packages for parameter identification: mpi4py sympy</p> <p>Required packages for mcmc bayesian identification: emcee corner schwimmbad tqdm statsmodels</p> <p>Required packages for sensitivity analysis : SALib==1.5.1 seaborn</p> <p>Required packages for CMAES: nevergrad</p> <p>Required packages for testing: pytest</p> <p>Required for some utilities: ruamel.yaml</p>"},{"location":"getting-started/#setting-up-your-python-path","title":"Setting up your python path","text":"<p>Open <code>[project_dir]/user_run_files/opencor_pythonshell_path.sh</code> file and change the <code>opencor_pythonshell_path</code> to the directory of pythonshell in the OpenCOR_dir: </p> <p>Note</p> Linux and MacWindows <pre><code>opencor_pythonshell_path=`&lt;OpenCOR_dir&gt;/pythonshell`.\n</code></pre> <pre><code>opencor_pythonshell_path=`C:\\&lt;OpenCOR_dir&gt;\\pythonshell.bat`.\n\nNote that the windows path conventions need to be used with C: and \"\\ rather than \"/\".\n</code></pre> <p>Note</p> <p>This tutorial assumes you will be running .sh commands (if you're on Windows, you should download gitbash from here so that you can run the bash scripts). </p> <p>However, alternatively (especially if you want to debug), you can use an IDE of your choice, set the python path equal to the <code>opencor_pythonshell_path</code> and run the python scripts that are called to within the bash scripts (open the relevent .sh file to find the corresponding python script name). The scripts are located at <code>project_dir]/src/scripts/</code></p> <p>Warning</p> <p>Installing mpi4py requires mpi to be available. Therefore, the following lines may be required to install the mpi software on your computer.</p> LinuxMacWindows <pre><code>sudo apt install libopenmpi-dev\nsudo apt install libffi7\n</code></pre> <pre><code>brew install openmpi\n</code></pre> <p>''' To be able to import mpi4py, you may have to do the following:</p> <p>Download MS MPI, install both .mis and SDK.</p> <p>Set up environmental variables. Open <code>Control Panel</code> and select <code>Advanced System Settings</code>. Then select <code>Environmental Variables</code> and add the following.</p> <pre><code>C:\\Program Files\\Microsoft MPI\\\nC:\\Program Files (x86)\\Microsoft SDKs\\MPI\\\n</code></pre> <p>'''</p> <p>Warning</p> <p>In versions of OpenCOR &lt; 0.8 you needed to nagivate to the <code>[OpenCOR_dir]/python/bin</code> directory and run the below command instead.</p> <pre><code>./python -m pip install &lt;packagename&gt;\n</code></pre> <p>Warning</p> <p>For OpenCOR &lt; 0.8 if you get an SSL error you must do the following before the pip install:</p> <pre><code>cd [OpenCOR_dir]/python/bin\nexport LD_LIBRARY_PATH=[OpenCOR_dir]/lib\n</code></pre> <p>This would let the system know where to look for libcrypto.so.3 when loading the ssl module.</p> <p>Changes to be made</p> <p>Currently vessels is used interchangeabley with modules. This will be changed to use modules in all instances, as the project now allows all types of modules, not just vessels.</p> <p>The connections between terminals and the venous system is hardcoded, as a terminal_venous_connection has to be made to sum up the flows and get an avergae concentration. This is being improved in development.</p>"},{"location":"identifiability-analysis/","title":"Identifiability Analysis","text":"<p>Identifiability Analysis (IA) ensures that identified parameters can be trusted, i.e. have a small uncertainty </p>"},{"location":"identifiability-analysis/#the-laplace-approximation","title":"The Laplace Approximation","text":"<p>The Laplace approximation makes an approximation of your parameter posterior distribution, assuming it is gaussian. This uses the Hessian of the log-likelihood with respect to the parameters. </p>"},{"location":"identifiability-analysis/#ia-in-circulatory_autogen","title":"IA in Circulatory_Autogen","text":"<p>IA is run following a parameter identification run.</p>"},{"location":"identifiability-analysis/#configuration-for-user_inputsyaml","title":"Configuration for <code>user_inputs.yaml</code>","text":"<p>To run IA, you need to set  <pre><code>do_ia: True\n</code></pre></p> <p>and add a specific <code>ia_options</code> block to your <code>user_inputs.yaml</code> configuration file: <pre><code>ia_options: \n    method: 'Laplace' \n</code></pre> Currently, the available options for the <code>method</code> are <code>'Laplace'</code>. </p>"},{"location":"model-generation-simulation/","title":"Model Generation and Simulation","text":""},{"location":"model-generation-simulation/#software-outline","title":"Software Outline","text":"<p>The Circulatory_Autogen project (<code>[project_dir]</code>) contains five folders as presented below:       </p> <ul> <li>resources: Contains example config csv files that define models (<code>[file_prefix]_vessel_array.csv</code>), parameters (<code>[file_prefix]_parameters.csv</code>), parameters to calibrate (<code>[file_prefix]_params_for_id.csv</code>), and ground truth data to calibrate towards (<code>[file_prefix]_obs_data.json</code>) for generating and calibrating models.</li> <li>src: Containts the source code for autogeneration, parameter id, and other utilities.</li> <li>user_run_files: Includes bash run files for the user and the <code>user_inputs.yaml</code> file, which is the main config file for the run settings.</li> <li>funcs_user: Contains user defined functions for calculating ouput features from model outputs, for fitting to ground truths. The corresponding src file, which contains other available functions to use in the parameter id is <code>[project_dir]/src/param_id/operation_funcs.py</code>. This directory also contains functions for user defined cost functions.</li> <li>module_config_user: Contains user defined units, cellml modules, and configuration files for those cellml modules. This allows the user to create their own modules and specify how they can be coupled with other modules. The corresponding src dir, which contains all of the src modules and config files is <code>[project_dir]/src/generators/resources/</code> </li> </ul> <p>Note</p> <p>For recommended use, the user should create a separate [CA_user_dir] for the specific model they are creating. In dir there should be the following:</p> <ul> <li>**[file_prefix]_user_inputs.yaml</li> <li>resources: Contains the config csv files that defines model connection network ([file_prefix]_vessel_array.csv) and parameters ([file_prefix]_parameters.csv) that will be generated and config files to prescribe the parameters to calibrate ([file_prefix]_params_for_id.csv) and the ground truth to calibrate towards ([file_prefix]_obs_data.json).</li> </ul> <p>Note</p> <p>set \"external_modules_dir\" to a directory where you store your cellml modules and config.json files if you want this to be external to the circulatory_autogen dir.  The cellml modules must end in modules.cellml</p> <p>The following folders will be generated in <code>[CA_user_dir]</code> (or <code>[project_dir]</code> if <code>user_inputs_path_override</code> isn't defined) after running model autogeneration and parameter identification.</p> <ul> <li>generated_models: Includes the generated code for the models that have been automatically generated. It also contains the generated models with parameters that have been fit with the parameter identification code. These models can be run in OpenCOR or through OpenCOR's version of Python.</li> <li>param_id_output: Includes all of the outputs from the parameter identification simulations, including predicted parameter values, minimum costs, standard deviations of parameters (if doing MCMC) and plots of the fitting results and parameter distributions.</li> </ul>"},{"location":"model-generation-simulation/#model-generation","title":"Model Generation","text":"<p>This section shows how to generate your desired model. There are several examples to show the generality of the circulatory_autogen software.</p> <p>The following are the steps for model autogeneration.</p> <ol> <li> <p>Create the vessel_array and parameters files in CSV format for the intended model. Standard names of vessel and parameters files are [model name]_vessel_array.csv and [model name]_parameters.csv, respectively. </p> <p>Those files should be added to your <code>resources</code> directory which is set with <code>resources_dir</code> in your <code>[CA_user_dir]/[file_prefix]_user_inputs.yaml</code> (or <code>[project_dir]/user_run_files/user_inputs.yaml</code> if <code>user_inputs_path_override</code> isn't defined). </p> </li> </ol> <p>Note</p> <p>The standard location for the resources dir is `[CA_user_dir]/resources</p> <p>Info</p> <p>If the name of your model is 3compartment, the user files needed for generation are:</p> <ul> <li><code>3compartment_vessel_array.csv</code></li> <li><code>3compartment_parameters.csv</code></li> </ul> <p>Note</p> <p>You can refer to the section Designing a new model for more details on creating vessel_array and parameters files.</p> <ol> <li> <p>Go to the <code>[CA_user_dir]</code> and open the <code>[file_prefix]_user_inputs.yaml</code> to edit. You can use gedit, nano, vim or your editor of choice to edit the file. <code>file_prefix</code> should be the name of your model. Subsequently, <code>input_param_file</code> should be equal to <code>[file_prefix]_parameters.csv</code> as shown below.</p> <p></p> </li> <li> <p>To run the autogeneration, navigate to the <code>user_run_files</code> directory and run the below command.</p> <pre><code>./run_autogeneration.sh\n</code></pre> <p>As shown below, this will create CellML files for the generated model and test that the simulation runs. Consequently, If there are no errors, it shows the \"Model generation has been successful.\" message at the end.</p> </li> </ol> <p>Note</p> <p>Alternatively, you can use an IDE of your choice, set the python path equal to the <code>opencor_pythonshell_path</code> (see getting started and  run script_generate_with_new_architecture.py from <code>[project_dir]/src/scripts</code></p> <p></p> <ol> <li> <p>Generated CellML files are located in the <code>[generated_models_dir]/[file_prefix]</code> directory. (The generated_models_dir defaults to <code>[project_dir]/generated_models</code> unless you set generated_models_dir in <code>[project_dir/user_run_files/user_inputs.yaml</code>). </p> <p>Four CellML files, and a CSV file will be generated. The CSV file includes the model parameters and the four CellML files contain the modules, parameters, units and constants, and main model.</p> <p></p> <p>Info</p> <p>For a typical autogeneration, the parameters.csv file will be the same as the parameters.csv file in <code>[project_dir]/resources</code> directory. However, when the parameter identification is run, it will contain the identified parameter values.</p> </li> </ol> <p>Note</p> <p>There is a test for the autogeneration running. To run the test, navigate to <code>user_run_files</code> and run the below command.</p> <pre><code>./run_test_autogeneration.sh\n</code></pre>"},{"location":"model-generation-simulation/#model-simulation","title":"Model Simulation","text":"<p>Once you have generated the models, open OpenCOR and open the generated <code>[file_prefix].cellml</code>, which is the main CellML file. This file automatically incorporates the <code>[file_prefix]_modules.cellml</code>, <code>[file_prefix]_parameters.cellml</code> and <code>[file_prefix]_units.cellml</code> files.</p> <p>When it is opened, click on the Simulation tab (highlighted with a yellow box in the below image). If there is no error, OpenCOR shows you a new page where models can be simulated. (If there is an error specific to the cellml code then it will be shown here.)</p> <p></p> <p>Several individual parts on this page are:</p> <ul> <li>Simulation settings</li> <li>ODE solver settings</li> <li>Parameters and variables</li> <li>Run control</li> <li>Run diagnostics</li> <li>Graphs and results</li> </ul> <p>You should set the simulation's starting, ending, and data output step size. Also, if you have a stiff problem you may need to set the maximum_time_step to a small value.</p> <p>ODE solver settings contains many settings related to the solver such as maximum step size, iteration method, absolute and relative tolerance, name of solver, etc. (shown in the blue box in the above image.)</p> <p>The parameters and variables section shows all constant and variable parameters that are used in the model (See section Creating a new model for more information on setting up parameters). You can plot variables by right-clicking each parameter you want for the y-axis and then choosing the x-axis variable (eg: time). </p> <p>The run control is on the top left section, as shown in the purple color box in the image. Click on the triangle button to run. For further control, see the OpenCOR Tutorial.</p> <p>The results will be shown after running the model. These results include run-time, settings, and other related parameters, as shown in the yellow box at the bottom of the image.</p>"},{"location":"other-features/","title":"Other Useful Features","text":""},{"location":"other-features/#other-useful-scripts","title":"Other Useful Scripts","text":"<p>These scripts can be found in <code>src/scripts/</code>. All files below are in development and the code may need to be changed for your own application.</p>"},{"location":"other-features/#generate_modules_filespy","title":"generate_modules_files.py","text":"<p>This script converts a generic cellml file into the modular format that can be used by Circulatory_Autogen. - It currently only works for models made from a single module</p>"},{"location":"other-features/#generate_obs_jsonpy","title":"generate_obs_json.py","text":"<p>This script contains an example of automating the creation of an obs_data.json file from input data. - Modify this for your own data if you don't want to modify the json file by hand</p>"},{"location":"other-features/#read_and_insert_parameterspy","title":"read_and_insert_parameters.py","text":"<p>This script modifies your parameters.csv file with the parameters and values in a json file that is input to the script when running it.</p>"},{"location":"parameter-identification/","title":"Parameter Identification","text":"<p>The parameter identification part of Circulatory_Autogen is designed to allow calibration of a model to experimental or clinical data. It implements an optimisation method to find the best fit parameters that give a minimal (local minima) error difference between the model output and the ground truth observables (experimental or clinical data or user specified). The creation of below two configuration files is necessary: </p> <ul> <li>params_for_id</li> <li>param id observables</li> </ul> <p>Those files should be added to the <code>[CA_dir]/resources</code> directory. Proper names of the files are [file_prefix]_params_for_id.csv and [file_prefix]_obs_data.json, respectively.</p>"},{"location":"parameter-identification/#creating-params_for_id-file","title":"Creating params_for_id file","text":"<p>This file defines which parameters (constants and initial_states) within your model that you will vary in the parameter id process and their allowed ranges (prior distribution). Following is an example of the <code>params_for_id.csv</code> file.</p> <p></p> <p>The entries in the file are detailed as follows:</p> <ul> <li>vessel_name: the name of the vessel/module the parameter is in</li> <li>param_name: the name of the parameter in the cellml module (not including the \"vessel_name\" suffix that is included in the <code>[file_prefix]_parameters.csv</code> file).</li> <li>param_type: \"state\" or \"const\"; whether the parameter is the initial value of a state or a const. </li> <li>min: The minimimum of the range of possible values (min of the uniform distribution).</li> <li>max: The maximum of the range of possible values (max of the uniform distribution).</li> <li>name_for_plotting: The name (latex format) that will be used when automatically potting comparisons with observables and predictions.</li> </ul> <p>Note</p> <p>param_type will be deprecated. All should be \"const\". Initial values that need to identified should be defined as constants within the cellml module.</p> <p>Info</p> <p>In the future we plan on including other types of priors rather than just uniform.</p>"},{"location":"parameter-identification/#creating-param-id-observables-file","title":"Creating param id observables file","text":"<p>This file defines the simulation protocol (protocol_info), and ground truth observables that will be used in the cost function for the parameter id optimisation algorithm. It also defines the measurement standard deviation, and weighting for each observable.</p> <p>File path of the obs_data.json file should be defined as param_id_obs_path in <code>[CA_dir]/user_run_files/user_inputs.yaml</code>.</p> <p>Note</p> <p>IMPORTANT: For creating obs_data.json files in python (strongly recommended over modifying the json by hand you can use the helper class in <code>src/utilities/obs_data_helpers.py</code>. See <code>src/scripts/example_format_obs_data_json_file.py</code> for an example  that you can copy and change for your parameter identification task.</p>"},{"location":"parameter-identification/#protocol-info","title":"protocol info","text":"<p>The protocol info defines the numerical experiments you will be running. Here is an example for a sympathetic neuron calibration where the input current is changed from 0 to 0.15 pA after 1 second then simulated for 2 seconds with that input current. This was performed in two experiments, the first experiment with a M-type potassium conductance of 0.08 uS and the second experiment with an increased M-type potassium channel conductance of 0.12 uS.</p> <p></p> <p>For the protocol we define each experiment as each new full simulation that needs to be run. Each subexperiment is a section of an experiment  with its own set of parameters. Subexperiments generally relate to different time periods where the inputs in the experiments that are being used for  calibration have a change in value (e.g. change in drug concentration, change in stimulatiion frequency, change in applied force). The entries in the protocol info are:</p> <ul> <li>pre_times: The amount of simulation that is done before you want to compare to observables or plot (this part of the simulation is thrown away. This is mainly used to simulate for an amout of time to reach steady state or periodic state. shape = (number of experiments)</li> <li>sim_times: The length in time of each subexperiment. shape=(number of experiments, number of subexperiments) -- Note: the shape isn't completely correct here, the number of subexperiments can be different for each experiment</li> <li>params_to_change: A dictionary where the key is a parameter name and the entry is the assigned value of that parameter in each (experiment_idx, subexperiment_idx).</li> <li>experiment_colors: The line color for the plots of each experiment. </li> <li>experiment_labels: The label for each experiment, which is used for plotting and naming plots.</li> </ul>"},{"location":"parameter-identification/#data-items","title":"data items.","text":"<p>Examples of <code>obs_data.json</code>, <code>data_item</code> entries are shown in below figures for constant, constant with operation_kwargs, series, and frequency data types, respectively. </p> <p> </p> <p>The entries in the data_item list in the <code>obs_data.json</code> file are:</p> <ul> <li>variable: This is the user defined observable name, it does not need to link to the cellml variable name.</li> <li>data_type: The format of the data. This can be \"constant\", \"series\", or \"frequency\" as shown above.</li> <li>unit: The unit of the observable.</li> <li>name_for_plotting: The name that will be in the automated plots comparing observable data to model output. (latex format)</li> <li>weight: The weighting to put on this observables entry in the cost function. Default should be 1.0</li> <li>std: The standard deviation which is used in the cost function. The cost function is the relative absolute error (AE) or mean squared error (MRE), each normalised by the std.</li> <li>value: The value of the ground truth, either a scalar for constant data_type, or a list of values for series or frequency data_types.</li> <li>obs_dt: not needed or set to \"null\" for constant and frequency data_types. It defines the dt for the observable series values. Not to be confused with the dt for the model simulation outputs.</li> <li>operation: This defines the operation that will be done on the operands/variable. The possible operations to be done on model outputs are defined in <code>[CA_dir]/src/param_id/operation_funcs.py</code> and in <code>[CA_dir]/operation_funcs_user/operation_funcs_user.py</code> for user defined operations.</li> <li>operation_kwargs: This is a dictionary of key word arguments (kwargs) and their values that links to the kwargs in the chosen python operation function.</li> <li>operands: The above defined \"operation\" can take in multiple variables. If operands is defined, then the \"variable\" entry will be a placeholder name for the calculated variable and the operands will define the model variables that are used to calculate the final feature that will be compared to the observable value entry/s.</li> </ul> <p>Warning</p> <p>obs_type: This has been deprecated in favor of the operation entry.</p>"},{"location":"parameter-identification/#running-external-cellml-models","title":"Running external cellml models","text":"<p>Running cellml models that weren't generated with Circulatory_Autogen is also just as straightforward:</p> <p>Simply set the <code>file_prefix</code> in your user_inputs.yaml file to the name of your cellml model <code>&lt;file_prefix&gt;.cellml</code>. Then set <code>generated_models_dir</code> to the path to the dir where your model subdir is and the subdir where the calibrated model will be generated. Make sure your cellml file/files are in a directory of the same name i.e.:</p> <p><code>path/to/your/generated_models_dir/&lt;file_prefix&gt;/&lt;file_prefix&gt;.cellml</code></p> <p>After calibration, the following directory will be created with your generated model:</p> <p><code>path/to/your/generated_models_dir/&lt;file_prefix&gt;_&lt;obs_file_name&gt;/</code></p> <p>Note</p> <p>Currently the generated model needs to be run in the new OpenCOR, with LibOpenCOR backend because a cellml2.0 model is generated</p>"},{"location":"parameter-identification/#creating-your-own-operations","title":"Creating your own operations","text":"<p>To enable flexibility we allow you to create your own user-defined operation functions in python to extract features from your model outputs and compare to data in the calibration. Available operation functions can be found in <code>src/param_id/operation_funcs.py</code> and in the file made for adding your own operation functions in <code>funcs_user/operation_funcs_user.py</code>. Here is an example of an operation function for calculating the ratio of the two peaks (used for mitral valve flow).</p> <p></p> <p>Note:</p> <ul> <li>kwargs can be used and defined for each entry in your obs_data.json with <code>operation_kwargs</code>, see above.</li> <li><code>if series_output</code> is needed to return the variable trace for plotting.</li> <li>A more elegant method of returning a high cost if the observable can't be calculated is being discussed.</li> </ul>"},{"location":"parameter-identification/#creating-your-own-cost-functions","title":"Creating your own cost functions","text":"<p>To allow even more flexibility, we also allow users to define their own cost functions (or likelihood functions). These can be found at <code>funcs_user/cost_funcs_user.py</code>. An example for the maximum likelihood estimator for gaussian noise (equivalent to weighted mean squared error) is:</p> <p></p> <p>Note:</p> <ul> <li>Currently there are no kwargs for user defined cost functions. But there will be: see issue</li> </ul>"},{"location":"parameter-identification/#solver","title":"Solver","text":"<p>Before doing calibration, a solver for the model needs to be chosen</p> <ul> <li>solver this defines what solver (and wrapper of that solver) to use. Options are: <ul> <li>CVODE: solver by Sundials, using opencor to wrap around CVODE </li> <li>CVODE_myokit: CVODE solver by Sundials, using myokit to wrap around CVODE </li> <li>solve_ivp: solver by scipy, using myokit to wrap around CVODE </li> </ul> </li> <li>solver_info this defines settings for the solver you have chosen<ul> <li>MaximumStep: maximum step size that the adaptive time step solver will use. Equal to dt if a non-adaptive time step solver is used</li> <li>MaximumNumberOfSteps: maximum number of substeps that the adaptive timestep solver will attempt before stepping</li> <li>method: any method for solve_ivp, e.g. RK45, BDF, etc. Not needed for CVODE as that is the solver and the method.</li> </ul> </li> </ul>"},{"location":"parameter-identification/#parameter-identification-settings","title":"Parameter Identification Settings","text":"<p>To run the parameter identification we need to set a few entries in the <code>[CA_dir]/user_run_files/user_inputs.yaml file</code>:</p> <ul> <li>param_id_method: this defines the optimisation method we use. Currently supported methods are:<ul> <li>genetic_algorithm: Genetic algorithm optimizer (default, well-tested)</li> <li>CMA-ES: Covariance Matrix Adaptation Evolution Strategy using Nevergrad (supports parallel execution)</li> <li>bayesian: Bayesian optimization using scikit-optimize (deprecated, untested)</li> </ul> </li> <li>pre_time: this is the amount of time the simulation is run to get to steady state before comparing to the observables from <code>obs_data.json</code>. IMPORTANT: THis is overwritten by the pre_times within the obs_data.json file, see the next section.</li> <li>sim_time: The amount of time used to compare simulation output and observable data. This should be equal to the length of a series observable entry divided by the \"sample_rate\". If not, only up to the minimum length of observable data and modelled data will be compared. </li> <li>maximum_step: The maximum time step for the CVODE solver</li> <li>dt: The output time step (This hasn't been tested well for anything but 0.01 s currently)</li> <li>param_id_obs_path: the path to the <code>obs_data.json</code> file described above.</li> <li>ga_options: Legacy dictionary (deprecated, use <code>optimiser_options</code> instead):<ul> <li>cost_type: \"AE\" or \"MSE\" for absolute error or mean squared error.</li> <li>num_calls_to_function: How many forward simulations of pre_time+sim_time will be run in the optimisation algorithm.</li> <li>cost_convergence: If the cost value is lower than this threshold then the calibration run is complete.</li> <li>max_patience: If the cost doesn't improve for this number of simulations, then calibration is complete (we assume that the cost has converged to the global minima or can't get out of a local minima).</li> </ul> </li> <li> <p>Note: For backwards compatibility, entries in <code>ga_options</code> are automatically merged into <code>optimiser_options</code> if not already present. It is recommended to use <code>optimiser_options</code> instead.</p> </li> <li> <p>optimiser_options: Dictionary for optimizer-specific options (preferred over <code>ga_options</code>). Common options shared across optimisers:</p> <ul> <li>num_calls_to_function: Maximum number of function evaluations (default: 10000)</li> <li>cost_convergence: Convergence tolerance for cost (default: 0.0001)</li> <li>max_patience: Maximum patience for convergence (default: 10)</li> <li>cost_type: Cost function type (e.g., 'MSE')</li> </ul> </li> </ul> <p>CMA-ES specific options:     - sigma0: Initial standard deviation for CMA-ES (optional, default: 0.2 of parameter range)     - Note:        - The number of parallel workers is automatically determined from the number of MPI processes       - Initial parameter values are automatically loaded from <code>{file_prefix}_parameters.csv</code></p> <ul> <li>ga_options: Legacy dictionary for optimization options. For backwards compatibility, entries in <code>ga_options</code> are automatically merged into <code>optimiser_options</code> if not already present. It is recommended to use <code>optimiser_options</code> instead.</li> </ul>"},{"location":"parameter-identification/#choosing-an-optimization-method","title":"Choosing an Optimization Method","text":""},{"location":"parameter-identification/#genetic-algorithm-genetic_algorithm","title":"Genetic Algorithm (genetic_algorithm)","text":"<ul> <li>Pros: Well-tested, robust, handles non-smooth cost functions well</li> <li>Cons: Can be slower, requires more function evaluations</li> <li>Best for: Complex, multi-modal optimization problems, when you have many function evaluations available</li> </ul>"},{"location":"parameter-identification/#cma-es-cma-es","title":"CMA-ES (CMA-ES)","text":"<ul> <li>Pros: Efficient gradient-free optimization, supports parallel execution, good convergence properties</li> <li>Cons: Requires Nevergrad package (<code>pip install nevergrad</code>)</li> <li>Best for: Smooth optimization landscapes, when you want faster convergence with parallel execution</li> </ul> <p>Example configuration for CMA-ES: <pre><code>param_id_method: CMA-ES\noptimiser_options:\n  num_calls_to_function: 10000  # shared option\n  cost_convergence: 0.001         # shared option\n  sigma0: 0.1                      # CMA-ES specific (optional, initial standard deviation)\n  # Note: Initial parameter values are automatically loaded from {file_prefix}_parameters.csv\n</code></pre></p> <p>Note: For backwards compatibility, <code>ga_options</code> can still be used and will be automatically merged into <code>optimiser_options</code>.</p>"},{"location":"parameter-identification/#running-parameter-identification","title":"Running parameter identification","text":"<p>After creating the params_for_id file and the param id observables file, and configuring the above settings, run the parameter identification using the below command.</p> <pre><code>./run_param_id.sh\n</code></pre> <p>Following a successful parameter id process, the model with updated parameters can be generated with:</p> <pre><code>./run_autogeneration_with_id_params.sh\n</code></pre> <p>Note</p> <p>IMPORTANT: After running the calibration, you should plot the simulation outputs vs the ground truth to analyse the fits!! This can be done with:</p> <pre><code>  ./plot_param_id.sh\n</code></pre> <p>The generated models will be saved in <code>generated_models/</code> directory and plots will be saved in <code>param_id_outputs/</code> directory.</p>"},{"location":"running-on-hpc/","title":"Running on HPC","text":""},{"location":"running-on-hpc/#abi-hpc-standard","title":"ABI HPC Standard","text":"<p>If running on the ABI HPC, you can use a pre-installed (with all neccesary libraries) OpenCOR pythonshell. To do this, you need to clone the circulatory_autogen repo into a directory of your choice, then change the opencor_pythonshell_path in opencor_pythonshell_path.sh to...</p> <p><code>opencor_pythonshell_path=/hpc/farg967/OpenCOR-0-8-1-Linux/pythonshell</code></p> <p>Following that to run in parallel you need to load mpich. Do the following from the {project_dir}/user_run_files dir:</p> <p><code>. load_mpi.sh</code></p> <p>Then you should be able to run as normal from the user_run_files dir</p>"},{"location":"running-on-hpc/#abi-hpc-extra","title":"ABI HPC Extra","text":"<p>If you need to install specific python libraries that aren't installed in the above OpenCOR python version, then you  will need to install a separate OpenCOR and install the libraries. See getting-started for how to install python libraries,  the process should be the same on the HPC.</p> <p>Warning</p> <p>Before installing mpi4py in your separate OpenCOR, make sure you load mpi with</p> <p><code>module load mpi/mpich-x86_64 &amp;&amp; echo \"succesfully loaded mpi/mpich-x86_64\"</code></p>"},{"location":"sensitivity-analysis/","title":"Sensitivity Analysis","text":"<p>Sensitivity Analysis (SA) is a recommended first step in the calibration pipeline because it performs crucial parameter screening. Calibration is the process of tuning numerous model parameters (inputs) until the model's output matches experimental data. Without SA, a modeler might waste weeks tuning parameters that have virtually no impact on the final result, or unknowingly tune parameters that are highly correlated, leading to non-unique solutions. SA efficiently identifies:</p> <ul> <li> <p>Influential parameters: Which parameters contribute most significantly to the model's output variance.</p> </li> <li> <p>Non-influential parameters: Which parameters can be fixed or ignored, drastically simplifying the calibration space.</p> </li> </ul> <p>SA ensures that the calibration effort is focused, efficient, and physically meaningful.</p>"},{"location":"sensitivity-analysis/#the-sobol-method","title":"The Sobol Method","text":"<p>The Sobol method is a powerful, global, variance-based sensitivity analysis technique. Unlike local methods that only test parameter changes one at a time, the Sobol method explores the entire input space simultaneously.</p> <ul> <li>Key Feature: It quantifies the contribution of each individual input parameter (First-Order Index, S_i) and the contribution of parameter interactions (Second-Order, Total-Order Index, S_{Ti}) to the overall output variance.</li> </ul> <p>This comprehensive approach allows modelers to understand not only which parameters are important on their own, but also how complex, synergistic interactions between two or more parameters drive the final simulation results.</p>"},{"location":"sensitivity-analysis/#sa-in-circulatory_autogen","title":"SA in Circulatory_Autogen","text":"<p>Since Sensitivity Analysis (SA) is intertwined with parameter identification, you will need the same input files as required for parameter identification. This includes both the <code>parameter_for_id.csv</code> and the <code>obs_data.json</code> files. However, the exact values of the data terms in the observation file are not critical for SA itself, as you are simply exploring parameter space and variance, not matching the simulation output to observed data.</p> <p>Crucially, each data item defined in your <code>obs_data.json</code> file is treated as a feature for SA, meaning you will receive a separate set of plots (one for first and total order indices, and one for second order indices) for each data item.</p>"},{"location":"sensitivity-analysis/#configuration-for-user_inputsyaml","title":"Configuration for <code>user_inputs.yaml</code>","text":"<p>To run the Sobol analysis, you need to add a specific <code>sa_options</code> block to your <code>user_inputs.yaml</code> configuration file: <pre><code>sa_options: \n    method: 'sobol' \n    num_samples: 1024 \n    sample_type: saltelli\n    output_dir: &lt;SA_outputs_path&gt;\n</code></pre> Currently, the available options for the <code>method</code> are <code>'naive'</code> and <code>'sobol'</code>. Available sample type are ['saltelli']. What we call <code>num_samples</code> here is actually the <code>num_samples</code> in</p> <p><code>actual_num_samples = num_samples (2M+2)</code></p> <p>where M is the number of parameters. This means the <code>num_samples</code> that you set doesn't need to be dependent on M.</p> <p>An indicator that the sample size may be too low is the observation of relatively large negative values for the Sobol indices in the results; if this occurs, you should increase the sample size and re-run the analysis.</p>"},{"location":"sensitivity-analysis/#how-to-run-sa-script","title":"How to run SA script","text":"<p>First, ensure you have the required sensitivity analysis packages specified in see getting started </p> <p>To run the script, use the following command (which utilizes MPI for parallelized computation on CPU):</p> <pre><code>./run_sensitivity_analysis &lt;NUM_CORES&gt;\n</code></pre> <p>After successful execution, you will find the SA plots\u2014including the first, second, and total order indices\u2014in the directory specified by <code>output_dir</code>.</p>"}]}