{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Circulatory Autogen","text":"<p>Circulatory Autogen aims to automate the process of combining CellML modules into a system model, then doing parameter identification to calibrate to clinical data. </p> <p>Common use cases include generating coupled biochemical cell models, generating neuron to cardiomyocyte models, generating patient specific 0D blood flow networks and more.</p>"},{"location":"#why-circulatory-autogen","title":"Why Circulatory Autogen","text":"<p>Circulatory Autogen provides the following benefits.</p> <ul> <li> <p>Allows module reusability in system models:</p> <p>This software allows reusability and easy coupling of CellML modules. A wide range of openly available modules can be accessed and easily coupled to whatever modules you want to develop. Therefore, instead of having one huge model that will rarely be reused, you can easily integrate modules to create a system model and the modules can be used by others. </p> </li> <li> <p>Provides the ability to calibrate model parameters to clinical or experimental data:</p> <p>This software supports parameter identification algorithms which you can use to calibrate the model parameters to clinical or experimental data.</p> </li> <li> <p>Code generation</p> <p>By generating models in CellML, the user can then re-generate their model in whatever language they want (C++, Fortran, Matlab) with libcellml. This allows for easy coupling with other types of models (PDE), C generation for embedded systems, and much more. </p> </li> <li> <p>Open Source</p> <p>Circulatory Autogen is completely open source. Unlike Software like Simulink, you will never need to pay to use Circulatory Autogen and you can continue using it outside of academia. This further promotes reproducible science by encouraging anyone to use and check the modules or models that are created.</p> </li> </ul>"},{"location":"#what-circulatory-autogen-can-do","title":"What Circulatory Autogen can do","text":"<p>Circulatory Autogen provides the following two main functionalities.</p> <ol> <li> <p>Model Autogeneration</p> <p>This generates a system model by combining CellML modules in a user-defined network/arrangement. For more information, refer section Model Generation and Simulation.</p> </li> <li> <p>Parameter Identification</p> <p>This allows calibrating model parameters to data. See section Parameter Identification for more information.</p> </li> </ol>"},{"location":"design-model/","title":"Designing a model","text":"<p>This section describes how to design a model to be run in Circulatory Autogen. There are two sub sections included in this guide as follows.</p> <ol> <li> <p>Creating a new model</p> </li> <li> <p>Converting an existing CellML model to run in Circulatory Autogen</p> </li> </ol>"},{"location":"design-model/#creating-a-new-model","title":"Creating a new model","text":"<p>This software is designed so the user can easily make their own modules and couple them with existing modules. The steps are as follows.</p> <ol> <li> <p>Either choose an existing <code>[module_category]_modules.cellml</code> file to write your module, or if it is a new category of module, create a <code>[module_category]_modules.cellml</code> file in <code>[project_dir]/module_config_user/</code>.</p> </li> <li> <p>Put your cellml model into the <code>[module_category]_modules.cellml</code> file.</p> </li> <li> <p>Create a corresponding module configuration entry into <code>[module_category]_config.json</code> within <code>[project_dir]/module_config_user/</code>. These module declarations detail the variables that can be accessed, the constants that must be defined and the available ports of the module.</p> </li> <li> <p>When possible, use units defined in <code>[project_dir]/src/generators/resources/units.cellml</code>. If  you need to define new units, define them in <code>[project_dir]/module_config_user/user_units.cellml</code></p> </li> <li> <p>Include your new module into a <code>[CA_user_dir]/[file_prefix]_vessel_array.csv</code> file.</p> <p>Note</p> <p>Modules that are connected as each others inputs and outputs will be coupled together with any ports with corresponding name. </p> <p>For an example, if VesselOne has an exit_port 'vessel_port' and VesselTwo has an entrance_port 'vessel_port', they will be coupled with the variables declared in their corresponding 'vessel_port'. You must be careful when making a new module, that the modules it couples to only has matching port types for the ones that are necessary for coupling.</p> <p>Additionally, if a module has a general_port [port_name], it will couple to any entrance, exit, or general port in a connected vessel with the port name [port_name]. </p> <p>Standard usage: entrance and exit ports are used for spatial connections (e.g. exit to entrance of a parent and daughter vessel), whereas general ports are used for non-spatial connections (e.g a port for a material property of a whole vessel)</p> </li> <li> <p>Define model constants in a <code>[CA_user_dir]/[file_prefix]_parameters.csv</code> file. OR run the autogeneration, which will call an error and create a <code>[CA_user_dir]/[file_prefix]_parameters_unfinished.csv</code>. See model generation and simulation</p> </li> </ol> <p>The following sections include more details on creating the above required files.</p>"},{"location":"design-model/#creating-vessel_array-and-parameter-files","title":"Creating vessel_array and parameter files","text":"<p>This section discusses creating a vessel_array and parameters files to build a new desired model.</p> <p>One standard vessel array file contains five important columns as elaborated in the table below. </p> <ul> <li>vessel_name is the name of a common organ or part of the cardiovascular system.</li> <li>BC_type is the type of the boundary condition for the vessel's input and output or more generally, the subtype of the module.</li> <li>vessel_type can be defined as the desired module which exists in the <code>[project_dir]/src/generators/resources/module_config.json</code> or one of the <code>[project_dir]/module_config_user/[model_category]_config.json</code> file. </li> <li>inp_vessel is the input of each part.</li> <li>out_vessel is the output of each part.</li> </ul> <p>Some examples of possible inputs</p> Column name Possible inputs vessel_name User defined, but it is better to use common names like 'heart', 'pvn', 'par', etc. BC_type 'vv', 'vp', 'pv', 'pp', 'pp_wCont', 'pp_wLocal', 'nn' (linked to BC_type in the module_config.json file) vessel_type 'heart', 'arterial', 'arterial_simple', 'venous', 'terminal', 'split_junction', 'merge_junction', '2in2out_junction', 'gas_transport_simple', 'pulomonary_GE', 'baroreceptor', 'chemoreceptor' (linked to vessel_type in the module_config.json file) inp_vessels name of the input vessels, which is one (or more) of the vessel_name entries in the other rows out_vessel name of the output vessels, which is one (or more) of the vessel_name entries in other rows <p>Below figure is an example of a vessel_array file.</p> <p></p> <p>Every row of the vessel array file represents a specific part or module in the defined system. Therefore, each module needs several parameters for modeling and generating a CellML file.</p> <p>These parameters should be inserted in the parameters file: <code>[resources_dir]/[file_prefix]_parameters.csv</code>.</p> <p>This file has the structure as shown below.</p> Column Name Description variable_name Parameter name units Unit in the defined units in CellML's unit file value Value of parameter data_reference Reference of the parameter value. Typically in [last_name][date][first_word_of_paper] format for papers. <p>The following is an example of a parameter file.</p> <p></p> <p>Note</p> <p>If you forget to add or insert any needed parameter in the file when you run the code, it shows you this message at the end:</p> <p></p> <p>At this time, you should open the <code>[resources_dir]/[file_prefix]_parameters_unfinished.csv</code>, which will include the parameters which were not inserted in the file with EMPTY_MUST_BE_FILLED value and data_reference entries. You should add the parameter value and reference, then copy the line to the original [file_prefix].csv file. Or you can add the value in the _unfinished.csv file then remove the last part of the file's name (\u201c_unfinished\u201d) (overwriting the original) and rerun the code with the correctly set parameters.</p>"},{"location":"design-model/#modules-and-definition-of-a-new-module","title":"Modules and definition of a new module","text":"<p>In the <code>[CA_dir]/src/generators/resources</code> directory, there are several CellML files which contain the modules that can be coupled together in your model. The <code>module_config.json file</code> defines the connection ports and variables of each cellml module. Additionally the cellml and .json files in module_config.user contains more available modules that have not yet been accepted into the source code.</p> <p></p> <p>If you want to create a new module, you can create or add to a <code>module_config_user/[module_category]_modules.cellml</code> and link to the file where the cellml file is contained, e.g. <code>tutorial_modules.cellml</code> or another cellml file in <code>[CA_dir]/module_config_user/</code> or <code>[CA_dir]/src/generators/resources/</code>.</p> <p>As shown in the below figure, there are three different parts for each module. The primary specification includes vessel_type, boundary condition type, and module_file, then the ports and their types, and finally, variables and constants.</p> <p></p> <p>Following is one of the modules in the <code>BG_modules</code> file. The main body of a specific module contains variables declaration, constitutive parameters, and state variables. Then, the constitutive relations and eventually, ODE equations.</p> <p></p>"},{"location":"design-model/#example-of-creating-a-new-module","title":"Example of creating a new module","text":"<p>This section shows a simple example to create a new module</p> <p>We want to define a new vessel type with the name of \"arterial\" with boundary condition type \"vp\". Additionally, we want to use the \"vp_type\" module, whose cellml code is shown in the above figure. Also, the module is located in the <code>BG_modules.cellml</code> file.</p> <p>Vessel_type, BC_type, module_format, module_file location, module_type and other related information are added to the <code>module_config.json</code> file, as shown below. We can now use this vessel_type in the vessel_array file in <code>[resources_dir]</code> to add the module with specified inputs, outputs and parameters. In the ports, you should add the \"vessel_port\" type for connecting to the other parts. Additionally, each module can be used in many vessel_types.</p> <p></p> <p>The entries in the <code>module_config.json</code> file are detailed as follows:</p> <ul> <li>vessel_type: This will be the \"vessel_type\" entry in the vessel_array file</li> <li>BC_type: This will be the \"BC_type\" entry in the vessel_array file</li> <li>module_format: Currently only cellml is supported but in the future, cpp modules and others will be allowed.</li> <li>module_file: The file within <code>[CA_dir]/src/generators/resources/</code> or <code>[CA_dir]/module_config_user/</code> that contains the cellml module that this config entry links to.</li> <li>module_type: The name of the module/computational_environment within the module cellml file.</li> <li>entrance_ports: Specification of the port types that this module can take if it is connected as an \"out_vessel\" to another module. If a port_type matches to the port_type of a exit_port in a module coupled as an input, then the port_types variables, e.g. [v_in, u] get mapped to the variables in the coupled modules exit port e.g. [v, u_out].</li> <li>exit_ports: Specification of the port types that this module can take if it is connected as an \"inp_vessel\" to another module.</li> <li>general_ports: Specification of the port types that this module can take if it is connected as any type of connection to another module. Port entries are:<ul> <li>port_types: The name of the type of port. If two vessels are connected vessel_a to vessel_b, and vessel_a has an exit_port with the same port_type as an entrance_port of vessel_b, then a connection will be made. </li> <li>variables: These are the variables within the module that will be connected to the variables in the corresponding port of the connected vessel/module.</li> </ul> <p>Note</p> <p>If you want a port variable to be able to couple to multiple other modules, you must set <code>\"multi_port\": \"True\"</code> as an entry within the entrance, exit, or general port.</p> </li> <li> <p>variables_and_units: This specifies all of the constants and the accesible variables of the cellml module. The entries are:</p> <ul> <li>[0] variable name: corresponding to the name in the cellml file</li> <li>[1] variable unit: corresponsing to the unit specification in <code>units.cellml</code></li> <li>[2] access or no_access: whether the variable can be accessed within the cellml simulation. This should always be \"access\" for accessibility, unless you want to decrease memory usage.</li> <li>[3] parameter type: can be constant, global_constant, variable, or boundary_condition.</li> <li>If parameter_type is boundary_condition it will be set to a variable accesses from another module if the corresponding port is connected. However, if the      corresponding port is not connected, the boundary_condition will be set to a constant, and required to be set in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file </li> </ul> <p>Note</p> <p>All constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file with the following naming convention: [variable_name]_[vessel_name].</p> <p>All global_constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file as just [variable_name].</p> </li> </ul>"},{"location":"design-model/#converting-an-existing-cellml-model-to-run-in-circulatory-autogen","title":"Converting an existing CellML model to run in Circulatory Autogen","text":"<p>Circulatory Autogen provides a script to convert an existing cellml model (with parameters hardcoded in the modules) to a format that can be used with Circulatory_Autogen, which is a format that defines parameters in a separate file so that they can be used in model calibration and specifies modules in a config file with ports for easy coupling of modules.).  You can find the script \"generate_modules_files.py\" at <code>[CA_dir]/src/scripts</code>.</p> <p>Update the script to change the <code>input_model</code> variable to the path of your CellML model and <code>output_dir</code> variable to the directory where you need to create the resources files and the new <code>[file_prefix]_user_inputs.yaml</code> file.</p> <p>This script generates the <code>[file_prefix]_modules.cellml</code> and <code>module_config.json</code> files in the <code>module_config_user</code> directory. <code>[file_prefix]_parameters.csv</code> and <code>[file_prefix]_vessel_array.csv</code> files are created in <code>[output_dir]/resources</code> and the <code>[file_prefix]_user_inputs.yaml</code> is created in <code>[output_dir]</code>.</p> <p>You only need to update the <code>user_inputs.yaml</code> file at the <code>user_run_files</code> directory to update <code>user_inputs_path_override:</code> to <code>[output_dir]/[file_prefix]_user_inputs.yaml</code> to run model autogeneration.</p> <p>Note</p> <p>You can update the file_prefix, vessel_name and the data_reference variables in the <code>generate_modules_files.py</code> at the <code>src/scripts</code> directory before running the script, so it will generate files with the defined variables.</p> <p>Warning</p> <p>You need to specify the variable name of time as the time_variable.</p> <p>Variable component_name should be the name of the component for which you want to generate files.</p>"},{"location":"example-3compartment-model/","title":"Example: 3Compartment Model","text":"<p>A schematic view of this model is shown above with details of boundary conditions, parts' names, vein connection, and direction of blood flow through. The heart is modeled as a simple valve module in this example. According to this schematic, the vessel and parameters files are designed as shown in below figures.</p> <p></p> <p></p> <p>In the <code>vessel_array</code> file, there are five columns: name, BC_type, vessel_type, inp_vessels, and out_vessels. </p> <p>name is the user-chosen module's name, for example \"heart\" or \"aortic_root\". </p> <p>BC_type is the boundary condition type for circulatory system vessels. The BC of vessel modules should be one of the \"vv\", \"vp\", \"pv\", and \"pp\" types. The first letter defines input pressure (p) or flow (v) boundary condition, the second letter defines output pressure (p) or flow (v) boundary condition. For example the pulmonary vein (pvn) in the above example has a vp BC type, meaning it has input flow and output pressure boundary conditions.</p> <p>Info</p> <p>A vessel with \"output flow\" BC must be connected to a vessel with \"input pressure\" BC and vice versa. E.g. a \"vp\" can only have either a \"vv\" or \"vp\" vessel as ouputs. This is checked in the software, and will throw an error if there are incorrect BC connections.</p> <p>The vessel_type and BC_type must match a module with the same vessel_type and BC_type in the modules_config.json defined at <code>[CA_dir]/src/generators/resources/</code>. </p> <p>This file is the config file which defines the variables of a module and the connection ports that allows linking between modules, each module links to a cellml module. For more information, refer Creating a new model section.</p> <p>inp_vessels and out_vessels are the inputs and outputs of each module, respectively. Some modules have multiple inputs and outputs, like split_type vessels that split from one to two vessels.</p> <p>Note</p> <p>The order of input and output vessels is important for the heart module. The order must be:</p> <p>inp_vessels:</p> <ol> <li>inferior vena cava</li> <li>superior vena cava</li> <li>pulmonary vein</li> </ol> <p>out_vessels: </p> <ol> <li>aorta</li> <li>pulmonary artery</li> </ol> <p>A simple two-vessel pulmonary system will be used if the pulmonary vessels are not included.</p> <p>Tip</p> <p>Currently, the terminal vessels should only have a BC_type starting with \"pp\".</p> <p>Results:</p> <p>In the below figure, three different variables are plotted versus time. The step size was adjusted to 0.01 seconds. These variables are the \"Aortic_root flow rate\", \"pvn flow rate\", and the \"volume of the heart\", respectively. </p> <p>This is the model before doing model calibration. See section Parameter Identification for info on the parameter identification.</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#initialising-and-startup","title":"Initialising and Startup","text":"<p>1. Install OpenCOR</p> <p>Download and install OpenCOR version 0.8.1 from this link. I recommend installing with zip/tarball in a directory where you have access and edit rights, such as ~/Desktop.</p> <p>Note</p> <p>If you are not familiar with OpenCOR, you should go through the OpenCOR Tutorial before starting this</p> <p>Download the OpenCOR tutorial, which is a comprehensive tutorial including many examples: OpenCOR Tutorial.</p> <p>2. Clone the project</p> <p>Clone the Circulatory Autogen project from the GitHub repository.</p> <p>Note</p> <p>If you have not worked with git and GitHub, firstly download and install git, and then open the terminal and navigate (with terminal in Linux/Mac or gitbash in Windows) to a directory where you want the repository to be. Then write these commands to clone the project on your pc:</p> <ul> <li><code>git clone https://github.com/FinbarArgus/circulatory_autogen</code></li> </ul> <p>If you want to develop the code, then create a fork of the above repo in GitHub, then do the following lines instead of the above:</p> <ul> <li> <p><code>git clone https://github.com/&lt;YourUsername&gt;/circulatory_autogen</code></p> </li> <li> <p><code>git remote add upstream https://github.com/FinbarArgus/circulatory_autogen</code></p> </li> </ul>"},{"location":"getting-started/#directory-definition","title":"Directory Definition","text":"<p>In this tutorial, we define the project_dir as the directory where the Github Circulatory Autogen project has been cloned. For example, on our computer, this directory is as below:</p> <p><code>[project_dir]: ~/Documents/git_projects/Circulatory_autogen</code></p> <p>Also, the OpenCOR directory is needed for installing the necessary python libraries, which we defined as the OpenCOR_dir, e.g.:</p> <p><code>[OpenCOR_dir]: ~/Desktop/OpenCOR-0-8-1-Linux/</code></p> <p>Info</p> <p>If running on the ABI HPC, you can use the installed OpenCOR version at the path: /hpc/farg967/OpenCOR-0-8-1-Linux/ and Ignore the below installation steps, as the libraries are already installed. See running on hpc</p>"},{"location":"getting-started/#python-and-libraries-installation","title":"Python and Libraries Installation","text":"<p>To run openCOR, you need to use the Python version that is shipped with openCOR. </p> <p>To install required python packages, navigate to <code>[OpenCOR_dir]</code> directory and run the below command.</p> <p>Note</p> LinuxMacWindows <pre><code>./pip install &lt;packagename&gt;\n</code></pre> <pre><code>./pythonshell -m pip install &lt;packagename&gt;\n</code></pre> <pre><code>./pythonshell.bat -m pip install &lt;packagename&gt;\n</code></pre> <p>Note</p> <p>Required packages for autogeneration: pandas pyyaml rdflib</p> <p>Recommended (but not required) packages for autogeneration (allows for better error checking): libcellml</p> <p>Required packages for parameter identification: mpi4py sympy</p> <p>Required packages for mcmc bayesian identification: emcee corner schwimmbad tqdm statsmodels</p> <p>Required for some utilities: ruamel.yaml</p>"},{"location":"getting-started/#setting-up-your-python-path","title":"Setting up your python path","text":"<p>Open <code>[project_dir]/user_run_files/opencor_pythonshell_path.sh</code> file and change the <code>opencor_pythonshell_path</code> to the directory of pythonshell in the OpenCOR_dir: </p> <p>Note</p> Linux and MacWindows <pre><code>opencor_pythonshell_path=`&lt;OpenCOR_dir&gt;/pythonshell`.\n</code></pre> <pre><code>opencor_pythonshell_path=`C:\\&lt;OpenCOR_dir&gt;\\pythonshell.bat`.\n\nNote that the windows path conventions need to be used with C: and \"\\ rather than \"/\".\n</code></pre> <p>Note</p> <p>This tutorial assumes you will be running .sh commands (if you're on Windows, you should download gitbash from here so that you can run the bash scripts). </p> <p>However, alternatively (especially if you want to debug), you can use an IDE of your choice, set the python path equal to the <code>opencor_pythonshell_path</code> and run the python scripts that are called to within the bash scripts (open the relevent .sh file to find the corresponding python script name). The scripts are located at <code>project_dir]/src/scripts/</code></p> <p>Warning</p> <p>Installing mpi4py requires mpi to be available. Therefore, the following lines may be required to install the mpi software on your computer.</p> LinuxMacWindows <pre><code>sudo apt install libopenmpi-dev\nsudo apt install libffi7\n</code></pre> <pre><code>brew install openmpi\n</code></pre> <p>''' To be able to import mpi4py, you may have to do the following:</p> <p>Download MS MPI, install both .mis and SDK.</p> <p>Set up environmental variables. Open <code>Control Panel</code> and select <code>Advanced System Settings</code>. Then select <code>Environmental Variables</code> and add the following.</p> <pre><code>C:\\Program Files\\Microsoft MPI\\\nC:\\Program Files (x86)\\Microsoft SDKs\\MPI\\\n</code></pre> <p>'''</p> <p>Warning</p> <p>In versions of OpenCOR &lt; 0.8 you needed to nagivate to the <code>[OpenCOR_dir]/python/bin</code> directory and run the below command instead.</p> <pre><code>./python -m pip install &lt;packagename&gt;\n</code></pre> <p>Warning</p> <p>For OpenCOR &lt; 0.8 if you get an SSL error you must do the following before the pip install:</p> <pre><code>cd [OpenCOR_dir]/python/bin\nexport LD_LIBRARY_PATH=[OpenCOR_dir]/lib\n</code></pre> <p>This would let the system know where to look for libcrypto.so.3 when loading the ssl module.</p> <p>Changes to be made</p> <p>Currently vessels is used interchangeabley with modules. This will be changed to use modules in all instances, as the project now allows all types of modules, not just vessels.</p> <p>The connections between terminals and the venous system is hardcoded, as a terminal_venous_connection has to be made to sum up the flows and get an avergae concentration. This is being improved in development.</p>"},{"location":"model-generation-simulation/","title":"Model Generation and Simulation","text":""},{"location":"model-generation-simulation/#software-outline","title":"Software Outline","text":"<p>The Circulatory_Autogen project (<code>[project_dir]</code>) contains five folders as presented below:       </p> <ul> <li>resources: Contains example config csv files that define models (<code>[file_prefix]_vessel_array.csv</code>), parameters (<code>[file_prefix]_parameters.csv</code>), parameters to calibrate (<code>[file_prefix]_params_for_id.csv</code>), and ground truth data to calibrate towards (<code>[file_prefix]_obs_data.json</code>) for generating and calibrating models.</li> <li>src: Containts the source code for autogeneration, parameter id, and other utilities.</li> <li>user_run_files: Includes bash run files for the user and the <code>user_inputs.yaml</code> file, which is the main config file for the run settings.</li> <li>funcs_user: Contains user defined functions for calculating ouput features from model outputs, for fitting to ground truths. The corresponding src file, which contains other available functions to use in the parameter id is <code>[project_dir]/src/param_id/operation_funcs.py</code>. This directory also contains functions for user defined cost functions.</li> <li>module_config_user: Contains user defined units, cellml modules, and configuration files for those cellml modules. This allows the user to create their own modules and specify how they can be coupled with other modules. The corresponding src dir, which contains all of the src modules and config files is <code>[project_dir]/src/generators/resources/</code> </li> </ul> <p>Note</p> <p>For recommended use, the user should create a separate [CA_user_dir] for the specific model they are creating. In dir there should be the following:</p> <ul> <li>**[file_prefix]_user_inputs.yaml</li> <li>resources: Contains the config csv files that defines model connection network ([file_prefix]_vessel_array.csv) and parameters ([file_prefix]_parameters.csv) that will be generated and config files to prescribe the parameters to calibrate ([file_prefix]_params_for_id.csv) and the ground truth to calibrate towards ([file_prefix]_obs_data.json).</li> </ul> <p>The following folders will be generated in <code>[CA_user_dir]</code> (or <code>[project_dir]</code> if <code>user_inputs_path_override</code> isn't defined) after running model autogeneration and parameter identification.</p> <ul> <li>generated_models: Includes the generated code for the models that have been automatically generated. It also contains the generated models with parameters that have been fit with the parameter identification code. These models can be run in OpenCOR or through OpenCOR's version of Python.</li> <li>param_id_output: Includes all of the outputs from the parameter identification simulations, including predicted parameter values, minimum costs, standard deviations of parameters (if doing MCMC) and plots of the fitting results and parameter distributions.</li> </ul>"},{"location":"model-generation-simulation/#model-generation","title":"Model Generation","text":"<p>This section shows how to generate your desired model. There are several examples to show the generality of the circulatory_autogen software.</p> <p>The following are the steps for model autogeneration.</p> <ol> <li> <p>Create the vessel_array and parameters files in CSV format for the intended model. Standard names of vessel and parameters files are [model name]_vessel_array.csv and [model name]_parameters.csv, respectively. </p> <p>Those files should be added to your <code>resources</code> directory which is set with <code>resources_dir</code> in your <code>[CA_user_dir]/[file_prefix]_user_inputs.yaml</code> (or <code>[project_dir]/user_run_files/user_inputs.yaml</code> if <code>user_inputs_path_override</code> isn't defined). </p> </li> </ol> <p>Note</p> <p>The standard location for the resources dir is `[CA_user_dir]/resources</p> <p>Info</p> <p>If the name of your model is 3compartment, the user files needed for generation are:</p> <ul> <li><code>3compartment_vessel_array.csv</code></li> <li><code>3compartment_parameters.csv</code></li> </ul> <p>Note</p> <p>You can refer to the section Designing a new model for more details on creating vessel_array and parameters files.</p> <ol> <li> <p>Go to the <code>[CA_user_dir]</code> and open the <code>[file_prefix]_user_inputs.yaml</code> to edit. You can use gedit, nano, vim or your editor of choice to edit the file. <code>file_prefix</code> should be the name of your model. Subsequently, <code>input_param_file</code> should be equal to <code>[file_prefix]_parameters.csv</code> as shown below.</p> <p></p> </li> <li> <p>To run the autogeneration, navigate to the <code>user_run_files</code> directory and run the below command.</p> <pre><code>./run_autogeneration.sh\n</code></pre> <p>As shown below, this will create CellML files for the generated model and test that the simulation runs. Consequently, If there are no errors, it shows the \"Model generation has been successful.\" message at the end.</p> </li> </ol> <p>Note</p> <p>Alternatively, you can use an IDE of your choice, set the python path equal to the <code>opencor_pythonshell_path</code> (see getting started and  run script_generate_with_new_architecture.py from <code>[project_dir]/src/scripts</code></p> <p></p> <ol> <li> <p>Generated CellML files are located in the <code>[generated_models_dir]/[file_prefix]</code> directory. (The generated_models_dir defaults to <code>[project_dir]/generated_models</code> unless you set generated_models_dir in <code>[project_dir/user_run_files/user_inputs.yaml</code>). </p> <p>Four CellML files, and a CSV file will be generated. The CSV file includes the model parameters and the four CellML files contain the modules, parameters, units and constants, and main model.</p> <p></p> <p>Info</p> <p>For a typical autogeneration, the parameters.csv file will be the same as the parameters.csv file in <code>[project_dir]/resources</code> directory. However, when the parameter identification is run, it will contain the identified parameter values.</p> </li> </ol> <p>Note</p> <p>There is a test for the autogeneration running. To run the test, navigate to <code>user_run_files</code> and run the below command.</p> <pre><code>./run_test_autogeneration.sh\n</code></pre>"},{"location":"model-generation-simulation/#model-simulation","title":"Model Simulation","text":"<p>Once you have generated the models, open OpenCOR and open the generated <code>[file_prefix].cellml</code>, which is the main CellML file. This file automatically incorporates the <code>[file_prefix]_modules.cellml</code>, <code>[file_prefix]_parameters.cellml</code> and <code>[file_prefix]_units.cellml</code> files.</p> <p>When it is opened, click on the Simulation tab (highlighted with a yellow box in the below image). If there is no error, OpenCOR shows you a new page where models can be simulated. (If there is an error specific to the cellml code then it will be shown here.)</p> <p></p> <p>Several individual parts on this page are:</p> <ul> <li>Simulation settings</li> <li>ODE solver settings</li> <li>Parameters and variables</li> <li>Run control</li> <li>Run diagnostics</li> <li>Graphs and results</li> </ul> <p>You should set the simulation's starting, ending, and data output step size. Also, if you have a stiff problem you may need to set the maximum_time_step to a small value.</p> <p>ODE solver settings contains many settings related to the solver such as maximum step size, iteration method, absolute and relative tolerance, name of solver, etc. (shown in the blue box in the above image.)</p> <p>The parameters and variables section shows all constant and variable parameters that are used in the model (See section Creating a new model for more information on setting up parameters). You can plot variables by right-clicking each parameter you want for the y-axis and then choosing the x-axis variable (eg: time). </p> <p>The run control is on the top left section, as shown in the purple color box in the image. Click on the triangle button to run. For further control, see the OpenCOR Tutorial.</p> <p>The results will be shown after running the model. These results include run-time, settings, and other related parameters, as shown in the yellow box at the bottom of the image.</p>"},{"location":"parameter-identification/","title":"Parameter Identification","text":"<p>The parameter identification part of Circulatory_Autogen is designed to allow calibration of a model to experimental or clinical data. It implements an optimisation method to find the best fit parameters that give a minimal (local minima) error difference between the model output and the ground truth observables (experimental or clinical data or user specified). The creation of below two configuration files is necessary: </p> <ul> <li>params_for_id</li> <li>param id observables</li> </ul> <p>Those files should be added to the <code>[CA_dir]/resources</code> directory. Proper names of the files are [file_prefix]_params_for_id.csv and [file_prefix]_obs_data.json, respectively.</p>"},{"location":"parameter-identification/#creating-params_for_id-file","title":"Creating params_for_id file","text":"<p>This file defines which parameters (constants and initial_states) within your model that you will vary in the parameter id process and their allowed ranges (prior distribution). Following is an example of the <code>params_for_id.csv</code> file.</p> <p></p> <p>The entries in the file are detailed as follows:</p> <ul> <li>vessel_name: the name of the vessel/module the parameter is in</li> <li>param_name: the name of the parameter in the cellml module (not including the \"vessel_name\" suffix that is included in the <code>[file_prefix]_parameters.csv</code> file).</li> <li>param_type: \"state\" or \"const\"; whether the parameter is the initial value of a state or a const. </li> <li>min: The minimimum of the range of possible values (min of the uniform distribution).</li> <li>max: The maximum of the range of possible values (max of the uniform distribution).</li> <li>name_for_plotting: The name (latex format) that will be used when automatically potting comparisons with observables and predictions.</li> </ul> <p>Note</p> <p>param_type will be deprecated. All should be \"const\". Initial values that need to identified should be defined as constants within the cellml module.</p> <p>Info</p> <p>In the future we plan on including other types of priors rather than just uniform.</p>"},{"location":"parameter-identification/#creating-param-id-observables-file","title":"Creating param id observables file","text":"<p>This file defines the simulation protocol (protocol_info), and ground truth observables that will be used in the cost function for the parameter id optimisation algorithm. It also defines the measurement standard deviation, and weighting for each observable.</p> <p>File path of the obs_data.json file should be defined as param_id_obs_path in <code>[CA_dir]/user_run_files/user_inputs.yaml</code>.</p>"},{"location":"parameter-identification/#protocol-info","title":"protocol info","text":"<p>The protocol info defines the numerical experiments you will be running. Here is an example for a sympathetic neuron calibration where the input current is changed from 0 to 0.15 pA after 1 second then simulated for 2 seconds with that input current. This was performed in two experiments, the first experiment with a M-type potassium conductance of 0.08 uS and the second experiment with an increased M-type potassium channel conductance of 0.12 uS.</p> <p></p> <p>For the protocol we define each experiment as each new full simulation that needs to be run. Each subexperiment is a section of an experiment  with its own set of parameters. Subexperiments generally relate to different time periods where the inputs in the experiments that are being used for  calibration have a change in value (e.g. change in drug concentration, change in stimulatiion frequency, change in applied force). The entries in the protocol info are:</p> <ul> <li>pre_times: The amount of simulation that is done before you want to compare to observables or plot (this part of the simulation is thrown away. This is mainly used to simulate for an amout of time to reach steady state or periodic state. shape = (number of experiments)</li> <li>sim_times: The length in time of each subexperiment. shape=(number of experiments, number of subexperiments) -- Note: the shape isn't completely correct here, the number of subexperiments can be different for each experiment</li> <li>params_to_change: A dictionary where the key is a parameter name and the entry is the assigned value of that parameter in each (experiment_idx, subexperiment_idx).</li> <li>experiment_colors: The line color for the plots of each experiment. </li> <li>experiment_labels: The label for each experiment, which is used for plotting and naming plots.</li> </ul>"},{"location":"parameter-identification/#data-items","title":"data items.","text":"<p>Examples of <code>obs_data.json</code>, <code>data_item</code> entries are shown in below figures for constant, constant with operation_kwargs, series, and frequency data types, respectively. </p> <p> </p> <p>The entries in the data_item list in the <code>obs_data.json</code> file are:</p> <ul> <li>variable: This is the user defined observable name, it does not need to link to the cellml variable name.</li> <li>data_type: The format of the data. This can be \"constant\", \"series\", or \"frequency\" as shown above.</li> <li>unit: The unit of the observable.</li> <li>name_for_plotting: The name that will be in the automated plots comparing observable data to model output. (latex format)</li> <li>weight: The weighting to put on this observables entry in the cost function. Default should be 1.0</li> <li>std: The standard deviation which is used in the cost function. The cost function is the relative absolute error (AE) or mean squared error (MRE), each normalised by the std.</li> <li>value: The value of the ground truth, either a scalar for constant data_type, or a list of values for series or frequency data_types.</li> <li>sample_rate: not needed or set to \"null\" for constant and frequency data_types. It defines the sample rate of the observable series values.</li> <li>operation: This defines the operation that will be done on the operands/variable. The possible operations to be done on model outputs are defined in <code>[CA_dir]/src/param_id/operation_funcs.py</code> and in <code>[CA_dir]/operation_funcs_user/operation_funcs_user.py</code> for user defined operations.</li> <li>operation_kwargs: This is a dictionary of key word arguments (kwargs) and their values that links to the kwargs in the chosen python operation function.</li> <li>operands: The above defined \"operation\" can take in multiple variables. If operands is defined, then the \"variable\" entry will be a placeholder name for the calculated variable and the operands will define the model variables that are used to calculate the final feature that will be compared to the observable value entry/s.</li> </ul> <p>Warning</p> <p>obs_type: This has been deprecated in favor of the operation entry.</p>"},{"location":"parameter-identification/#creating-your-own-operations","title":"Creating your own operations","text":"<p>To enable flexibility we allow you to create your own user-defined operation functions in python to extract features from your model outputs and compare to data in the calibration. Available operation functions can be found in <code>src/param_id/operation_funcs.py</code> and in the file made for adding your own operation functions in <code>funcs_user/operation_funcs_user.py</code>. Here is an example of an operation function for calculating the ratio of the two peaks (used for mitral valve flow).</p> <p></p> <p>Note:</p> <ul> <li>kwargs can be used and defined for each entry in your obs_data.json with <code>operation_kwargs</code>, see above.</li> <li><code>if series_output</code> is needed to return the variable trace for plotting.</li> <li>A more elegant method of returning a high cost if the observable can't be calculated is being discussed.</li> </ul>"},{"location":"parameter-identification/#creating-your-own-cost-functions","title":"Creating your own cost functions","text":"<p>To allow even more flexibility, we also allow users to define their own cost functions (or likelihood functions). These can be found at <code>funcs_user/cost_funcs_user.py</code>. An example for the maximum likelihood estimator for gaussian noise (equivalent to weighted mean squared error) is:</p> <p></p> <p>Note:</p> <ul> <li>Currently there are no kwargs for user defined cost functions. But there will be: see issue</li> </ul>"},{"location":"parameter-identification/#parameter-identification-settings","title":"Parameter Identification Settings","text":"<p>To run the parameter identification we need to set a few entries in the <code>[CA_dir]/user_run_files/user_inputs.yaml file</code>:</p> <ul> <li>param_id_method: this defines the optimisation method we use. Currently this can only be genetic_algorithm, but more methods are being implemented. Eventually we aim to use CVODES to allow for gradient based optimisation methods.</li> <li>pre_time: this is the amount of time the simulation is run to get to steady state before comparing to the observables from <code>obs_data.json</code>. IMPORTANT: THis is overwritten by the pre_times within the obs_data.json file, see the next section.</li> <li>sim_time: The amount of time used to compare simulation output and observable data. This should be equal to the length of a series observable entry divided by the \"sample_rate\". If not, only up to the minimum length of observable data and modelled data will be compared. </li> <li>maximum_step: The maximum time step for the CVODE solver</li> <li>dt: The output time step (This hasn't been tested well for anything but 0.01 s currently)</li> <li>param_id_obs_path: the path to the <code>obs_data.json</code> file described above.</li> <li>ga_options:<ul> <li>cost_type: \"AE\" or \"MSE\" for absolute error or mean squared error.</li> <li>num_calls_to_function: How many forward simulations of pre_time+sim_time will be run in the optimisation algorithm.</li> </ul> </li> <li>Note: In the future entries to ga_options will be kwargs that are used in the underlying user defined optimisation schemes (see link)</li> </ul>"},{"location":"parameter-identification/#running-parameter-identification","title":"Running parameter identification","text":"<p>After creating the params_for_id file and the param id observables file, and configuring the above settings, run the parameter identification using the below command.</p> <pre><code>./run_param_id.sh\n</code></pre> <p>Following a successful parameter id process, the model with updated parameters can be generated with:</p> <pre><code>./run_autogeneration_with_id_params.sh\n</code></pre> <p>Note</p> <p>IMPORTANT: After running the calibration, you should plot the simulation outputs vs the ground truth to analyse the fits!! This can be done with:</p> <pre><code>  ./plot_param_id.sh\n</code></pre> <p>The generated models will be saved in <code>generated_models/</code> directory and plots will be saved in <code>param_id_outputs/</code> directory.</p>"},{"location":"running-on-hpc/","title":"Running on HPC","text":""},{"location":"running-on-hpc/#abi-hpc-standard","title":"ABI HPC Standard","text":"<p>If running on the ABI HPC, you can use a pre-installed (with all neccesary libraries) OpenCOR pythonshell. To do this, you need to clone the circulatory_autogen repo into a directory of your choice, then change the opencor_pythonshell_path in opencor_pythonshell_path.sh to...</p> <p><code>opencor_pythonshell_path=/hpc/farg967/OpenCOR-0-8-1-Linux/pythonshell</code></p> <p>Following that to run in parallel you need to load mpich. Do the following from the {project_dir}/user_run_files dir:</p> <p><code>. load_mpi.sh</code></p> <p>Then you should be able to run as normal from the user_run_files dir</p>"},{"location":"running-on-hpc/#abi-hpc-extra","title":"ABI HPC Extra","text":"<p>If you need to install specific python libraries that aren't installed in the above OpenCOR python version, then you  will need to install a separate OpenCOR and install the libraries. See getting-started for how to install python libraries,  the process should be the same on the HPC.</p>"}]}